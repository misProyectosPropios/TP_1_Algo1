\documentclass[10pt,a4paper]{article}

\input{AEDmacros}

\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Especificaci\'on}
\subtitulo{Especificacion y correctitud en SmallLang}

\fecha{\today}

\materia{Algoritmo y estructura de datos}
\grupo{Compilados}

\integrante{Frutos, I\~{n}aki}{74/24}{inakifrutos00@gmail.com}
\integrante{Pucciarelli, Francisco}{802/22}{franciscopucciarelli99@gmail.com}
\integrante{Berney, Ignacio}{758/24}{nachoberney@gmail.com}
\integrante{Di Scala,Juan}{192/23}{jusnmadiscala24012003@gmail.com}

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle

\section{Preguntas}
\subsection{Especificaci\'on}


    \begin{enumerate}
        \item \textbf{grandesCiudades}: A partir de una lista de ciudades, devuelve aquellas que tienen m\'as de 50.000 habitantes.
        \begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}} {\TLista{Ciudad}}\end{proc}

        \item \textbf{sumaDeHabitantes}: Por cuestiones de planificaci\'on urbana, las ciudades registran sus habitantes mayores de edad
        por un lado y menores de edad por el otro. Dadas dos listas de ciudades del mismo largo con los mismos nombres, una
        con sus habitantes mayores y otra con sus habitantes menores, este procedimiento debe devolver una lista de ciudades
        con la cantidad total de sus habitantes.

        \begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{\TLista{Ciudad}}\end{proc}

        \item \textbf{hayCamino}: Un mapa de ciudades est\'a conformada por ciudades y caminos que unen a algunas de ellas. A partir de
        este mapa, podemos definir las distancias entre ciudades como una matriz donde cada celda i, j representa la distancia
        entre la ciudad i y la ciudad j (Fig. 2). Una distancia de 0 equivale a no haber camino entre i y j. Notar que la distancia
        de una ciudad hacia s\'i misma es cero y la distancia entre A y B es la misma que entre B y A.


        Dadas dos ciudades y una matriz de distancias, se pide determinar si existe un camino entre ambas ciudades.

        \begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{\bool}\end{proc}

        \item \textbf{cantidadCaminosNSaltos}: Dentro del contexto de redes inform\'aticas, nos interesa contar la cantidad de “saltos”
        que realizan los paquetes de datos, donde un salto se define como pasar por un nodo.
        As\'i como definimos la matriz de distancias, podemos definir la matriz de conexi\'on entre nodos, donde cada celda i, j
        tiene un 1 si hay un  \'unico camino a un salto de distancia entre el nodo i y el nodo j, y un 0 en caso contrario. En este
        caso, se trata de una matriz de conexi\'on de orden 1, ya que indica cu\'ales pares de nodos poseen 1 camino entre ellos a
        1 salto de distancia.

        Dada la matriz de conexi\'on de orden 1, este procedimineto debe obtener aquella de orden n que indica cu\'antos caminos
        de n saltos hay entre los distintos nodos. Notar que la multiplicaci\'on de una matriz de conexi\'on de orden 1 consigo
        misma nos da la matriz de conexi\'on de orden 2, y as\'i sucesivamente.

        \begin{proc}{cantidadCaminosNSaltos}{\Inout conexion : \TLista{\TLista{\ent}}, \In n : \ent}{}\end{proc}
        %\begin{proc}{cantidadCaminosNSaltos}{\Inout conexi\'on: \TLista{\TLista{\ent}}, \in n: \ent}{\ent}\end{proc}

        \item \textbf{caminoM\'inimo}: Dada una matriz de distancias, una ciudad de origen y una ciudad de destino, este procedimiento
        debe devolver la lista de ciudades que conforman el camino m\'as corto entre ambas. En caso de no existir un camino,
        se debe devolver una lista vac\'ia

        \begin{proc}{caminoM\'inimo}{\In origen : \ent, \In destino : \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}
        \end{proc}
    \end{enumerate}

\subsection{Demostraciones de correctitud}

La funci\'on poblaci\'onTotal recibe una lista de ciudades donde al menos una de ellas es grande (es decir, supera los
50.000 habitantes) y devuelve la cantidad total de habitantes. Dada la siguiente especificaci\'on:



\begin{proc} {poblaci\'onTotal}{\In ciudades : \TLista{Ciudad}}{\ent}
{
    \requiere{  \\ 
        \existe[unalinea]{i}{\ent}{0 \leq i < |ciudades| \yLuego ciudades[i].habitantes > 50.000} \land \\
        \paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego ciudades[i].habitantes \geq 0} \land \\
        %\paraTodo[unalinea]{i, j}{\ent}{0 \leq i < j < |ciudades| \implicaLuego ciudades[i].nombre \neq ciudades[j].nombre}
        }
    \asegura{
        res =  \sum\limits_{k=0}^{|secuencia| - 1}{ciudades[i].habitantes}
    }
}
\end{proc}


\begin{lstlisting}
res = 0
i = 0
while (i < ciudades.length) do
    res = res + ciudades[i].habitantes 
    i = i + 1
endwhile
\end{lstlisting}

    \begin{enumerate}
        \item Demostrar que la implementaci\'on es correcta con respecto a la especificaci\'on
        \item Demostrar que el valor devuelto es mayor a 50.000.
    \end{enumerate}


%\newpage


%Respuestas del trabajo
\section{Respuestas}

%Respuestas del punto 1
\subsection{Especificaci\'on}

\begin {enumerate}
    %Ejercicio 1.1)
    %TODO Borrar el pred sinReptidos
    %TODO Borrar el que dice sinRepetidos y agregar una sumatoria que diga que si hay una tupla que se repite, entonces aparezca la misma cantidad de veces
    \item \begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}} {\TLista{Ciudad}}
		\requiere{sonTodosPositivos(ciudades)} 
		\requiere{sinRepetidos(ciudades)} 
		 
        \asegura{
            sinRepetidos(res)
        }
	    \asegura{ \\
			\paraTodo[unalinea]{i}{Ciudad}{((i \in ciudades) \land (i.habitantes \geq 50.000)) \Rightarrow (i \in res) \land \\ 
			\paraTodo[unalinea]{j}{Ciudad}{(j \in res) \Rightarrow ((j.habitantes \geq 50.000) \land j \in ciudades)} 
			}
        }
        %\left( \left( \forall i:Ciudad \right)\left( \left( \left( i\in ciudades \right)\wedge \left( i_{1}\ge 50.000 \right) \right)\to \left( i\in res \right) \right) \right) \wedge \left( \left( \forall j:Ciudad \right)\left( \left( j\in res \right)\to \left( \left( j_{1}\ge 50.000 \right)\wedge \left( j\in ciudades \right) \right) \right) \right)

	    \pred{sonTodosPositivos}{ciudades: \TLista{Ciudad}}{
			\paraTodo[unalinea]{i}{Ciudad}{i \in ciudades \Rightarrow i.habitantes \geq 0}
		}

		\pred{sinRepetidos}{ciudades: \TLista{Ciudad}}{ 
			\paraTodo[unalinea]{i}{Ciudad}{i \in ciudades \Rightarrow \neg(
				\existe[unalinea]{j}{Ciudad}{j \in ciudades \land j.nombre = i.nombre}
			)}
		}
    \end{proc}

	%Comentarios del 1.1)
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item Una ciudad con habitantes negativos (cantidad) no tiene sentido. Si bien no rompe el res (pues no los considera), no lo tomamos como entrada válida
				\item Tampoco tomamos como entrada válida una secuencia que tenga dos (o más) tuplas con $1^{ra}$ componente igual. Si bien en la realidad puede pasar la gran casualidad que existan 2 ciudades distitnas con mismos nombre, vamos a pedir que se distingas utilizando nombres distintos
				
			\end{enumerate}

		}
	}

    %TODO Modificar el asegura
    %Ejercicio 1.2)
   	\item \begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{\TLista{Ciudad}}
		\requiere{sinRepetidos(menoresDeCiudades) \land sinRepetidos(mayoresDeCiudades) }
		\requiere{|menoresDeCiudades| = |mayoresDeCiudades| }
		\requiere{(todosElementosPositivos(menoresDeCiudades)) \land (todosElementosPositivos(mayoresDeCiudades))}
		\requiere{estanContenidos(menoresDeCiudades,mayoresDeCiudades) \land \\ estanContenidos(mayoresDeCiudades,menoresDeCiudades)}
		
		\asegura{|res|=|mayoresDeCiudades|}
		\asegura{estanContenidos(menoresDeCiudades,res)\land estanContenidos(res,menoresDeCiudades)}
        \asegura{
            \paraTodo[unalinea]{i}{Ciudad}{i \in res \to \\
                \existe[unalinea]{j}{\ent}{ 
                    0\leq j<|menoresDeCiudades| \yLuego menoresDeCiudades[j].nombre = i.nombre \land \\
                    \existe[unalinea]{k}{\ent}{
                        0 \leq k <|mayoresDeCiudades| \yLuego mayoresDeCiudades[k].nombre= i.nombre \land \\
                        i.habitantes = menoresDeCiudades[j].habitantes + mayoresDeCiudades[k].habitantes
                    }
                }
            }
        }
        
     %   \asegura{\paraTodo[unalinea]{i}{\Ciudad}{i \in res \to \existe[unalinea]{j}{\ent}{0\leq j<|menoresDeCiudades| \yLuego \\
     %   menoresDeCiudades[j].nombre = i.nombre}
     %   
     %   }}
       % \existe[unalinea]{k}{\ent}{0 \leq k <|mayoresDeCiudades| \yLuego mayoresDeCiudades[k].nombre= i.nombre \land i.habitantes = menoresDeCiudades[j].habitantes + mayoresDeCiudades[k].habitantes)
       % }}}
      %  \asegura{\existe[unalinea]{j}{\ent}{0\leq j<|menoresDeCiudades| \yLuego menoresDeCiudades[j].nombre = t.nombre \land \existe[unalinea]{k}{\ent}{0 \leq k <|mayoresDeCiudades| \yLuego mayoresDeCiudades[k].nombre=t.nombre \land (t.habitantes = menoresDeCiudades[j].habitantes + mayoresDeCiudades[k].habitantes)}}}
		%\asegura{res=\True \iff  ((\exists j:\mathds{Z})((0\leq j<|menoresDeCiudades| \land _{L} menoresDeCiudades[j].nombre=t.nombre) \land (\exists k:\mathds{Z})((0\leq k <|mayoresDeCiudades| \land _{L} mayoresDeCiudades[k].nombre=t.nombre) \land \\ (t.habitantes=menoresDeCiudades[j].habitantes+mayoresDeCiudades[k].habitantes)))}
		

        \pred{sinRepetidos}{s: \TLista{Ciudad}}{
            \paraTodo[unalinea]{i,j}{\ent}{0 \leq i, j < |s| \land i \neq j \implicaLuego s[i].nombre \neq s[j].nombre}
        }
		
		\pred{todosElementosPositivos}{s: \TLista{Ciudad}}{
			\paraTodo[unalinea]{i}{\ent}{0\leq i<|s| \implicaLuego s[i].habitantes \geq 0}
		}

		\pred{estanContenidos}{s,t: \TLista{Ciudad}} 
        {\paraTodo[unalinea]{i}{Ciudad}{i \in s \to \existe[unalinea]{j}{Ciudad}{j \in t \land i.nombre = j.nombre}}}
		%{(\forall v: Ciudad)(v\in s\rightarrow (\exists w:Ciudad) (w \in t \land w.nombre=v.nombre)) }
	\end{proc}
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item No hay repetidos entre mayores y menores, para evitar conflictos en los casos en los que no se podrían diferenciar las ciudades si se llaman igual
				\item Por ejercicio, tiene que tener la misma cantidad de elementos la secuencia de menores y mayores
    			\item Tiene que ser $\geq $ 0 la cantidad de habitantes, porque si es negativo no tendría sentido alguno, al ser las cantidadaes siempre positivas
				\item Cada ciudad que aparece en alguna secuencia, tiene que aparecer en la otra necesariamente
                \item En el segundo asegura estamos afirmando la doble implicación de conjuntos, dejando implícito que res tiene exactamente los mismos nombres (en las tuplas) que la lista de secuencia de ciudades. De esta forma, nos aseguramos que res no contenga elementos de más por fuera de la secuencia de entrada.
   			\end{enumerate}
		}
	}

    %Ejercicio 1.3)
    %TODO agregar que el hayCamino verifique que los rangos esten entre 0 y el |seq|
   \item \begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{\bool}

            \requiere{(0 \leq desde < |distancias|) \land (0 \leq hasta < |distancias|) }
            \requiere{(esMatrizCuadrada(distancias))  }
            \requiere{(esMatrizSimetrica(distancias))  }
            \requiere{(todosElementosPositivos(distancias)) }
            \requiere{(es0EnDiagonalPrincipal(distancias)) }
	    \asegura{\\
            res = \True \iff \existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto(distancias, i, desde, hasta)} 
         %\existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto()}  \Rightarrow res = \true
        }

	    \pred{esCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, posibleCamino: \TLista{\ent}, desde: \ent, hasta: \ent}
        {(|posibleCamino | \geq 2) \land sonCiudadesValidas(|distancias|, posibleCamino) \yLuego \\
        (posibleCamino[0] = desde \land posibleCamino[|posibleCamino| - 1] = hasta) \land \\ 
        \paraTodo[unalinea]{x}{\ent}{1 \leq x < |posibleCamino| \implicaLuego ((distancias[posibleCamino[x]][posibleCamino[x - 1]] \neq 0))} } 


        \pred{sonCiudadesValidas}{maxCiudades:  \ent, posCamino: \TLista{\ent}}{
            \paraTodo[unalinea]{i}{\ent}{0 \leq i<|posCamino| \implicaLuego 0 \leq posCamino[i] < maxCiudades}
        }
        
        \pred{esMatrizCuadrada}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego |matriz[i]| = |matriz|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {esMatrizCuadrada(matriz) \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implica \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}
   
        \pred{todosElementosPositivos}{s: \TLista{\TLista{\ent}}}{
            \paraTodo[unalinea]{i}{\ent}{ 0 \leq i < |s| \implica
                \paraTodo[unalinea]{j}{\ent}{  0 \leq j < |s[i]| \implicaLuego s[i][j] \geq 0}
            }
        }
        
        \pred{es0EnDiagonalPrincipal}{matriz: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(matriz)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego matriz[i][i] = 0}
        }
   \end{proc}

   \fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item La matriz distancias tienen que ser matrices cuadradas, pues
				asi se definia la matriz distancia en el ejercicio
				\item La matriz distancias también tiene que ser simetrica, pues así
				se definía en el ejercicio
                \item Los elemenentos tienen que ser positivos, ya que las distancias no pueden ser nunca negativas
                \item La distancia de un punto A al mismo es 0, por el ejercicio, y gracias a eso, tenemos que la diagonal principal es
                0 
			\end{enumerate}

		}
	}

    %Ejercicio 1.4)
    %TODO agregar que cuando verifique la matriz al cuadrado, diga que todas las matrices de ese ejemplo sean al cuadradas y de largo n mismo que las matrices
    \item \begin{proc}{cantidadCaminosNSaltos}{\Inout conexion : \TLista{\TLista{\ent}}, \In n : \ent}{}
		\requiere{conexion = conexion_{0} }
        \requiere{n > 0 }
        \requiere{(esMatrizCuadrada(conexion)) }
        \requiere{(esMatrizSimetrica(conexion)) }
        \requiere{(todosElementos\_1\_o\_0(conexion)) }
        \requiere{(es0EnDiagonalPrincipal(conexion)) }

	    \asegura{ \\
            (n = 1 \land conexion = conexion_{0}) \lor \\ %Que pasa si en un if then else hay dos condiciones con lo mismo?
            (n > 1 \land \existe[unalinea]{i}{\TLista{\TLista{\TLista{\ent}}}}{|i| = n \yLuego  i[0] = conexion_{0} \land \\ 
                \paraTodo[unalinea]{j}{\ent}{1 \leq j < |i| \implicaLuego esMultiplicacionDe(conexion_{0}, i[j - 1], i[j])} \land conexion = i[|i| - 1]
            })
        }
	    
        \pred{esMatrizCuadrada}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego |matriz[i]| = |matriz|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {esMatrizCuadrada(matriz) \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implica \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}%\paraTodo{i}{\ent}{}}
   
        \pred{todosElementos\_1\_o\_0}{matriz: \TLista{\TLista{\ent}}}{
            \paraTodo[unalinea]{i}{\ent}{ 0 \leq i < |matriz| \implica
                \paraTodo[unalinea]{j}{\ent}{  0 \leq j < |matriz[i]| \implicaLuego (matriz[i][j] = 0 \lor matriz[i][j] = 1)}
           }
        }
        
        \pred{es0EnDiagonalPrincipal}{matriz: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(matriz) \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego matriz[i][i] = 0}
        } 


        \pred{esMultiplicacionDe}{matrizAMultiplicar, matrizMultiplicada, res: \TLista{\TLista{\ent}}}{
            esMatrizCuadrada(matrizAMultiplicar) \land \\ 
            esMatrizCuadrada(matrizMultiplicada) \land \\
            esMatrizCuadrada(res) \land \\
            |matrizAMultiplicar| =  |matrizMultiplicada| \land |res| = |matrizMultiplicada| \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |matrizAMultiplicar| \implica  \\
                \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matrizAMultiplicar[i]| \implicaLuego \\
                res[i][j] = productoEscalar(matrizAMultiplicar[i], matrizMultiplicada[j])
                }
            }
        }

        \aux{productoEscalar}{vector1, vector2: \TLista{\ent}}{\ent}{
            \sum\limits_{k = 0}^{min(|vector1|, |vector2|) - 1}{vector1[k] * vector2[k]}
        }
    \end{proc}

	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item Un camino de 0 saltos no tiene sentido, pues los caminos tenian al menos 1 salto
				\item Luego, si es de 1 salto, entonces deberia devolver la misma matriz
				\item Si n es mayor o igual a 2, entonces elevarlo ya lo sabemos como se hace correctamente y no tenemos problemas
                \item En realidad, el producto matricial es entre filas y columnas. Pero como son matrices simétricas, es equivalente a hacer filas por filas.
			\end{enumerate}

		}
	}

    %Ejercicio 1.5)
    %TODO agregar que el hayCamino verifique que los rangos esten entre 0 y el |seq|
    %TODO el que pase por 2 ciduades ya lo verificamos
    \item \begin{proc}{caminoM\'inimo}{\In origen : \ent, \In destino : \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}

        \requiere{(0 \leq origen < |distancias|) \land (0 \leq destino < |distancias|) }
        \requiere{(esMatrizCuadrada(distancias)) }
        \requiere{(esMatrizSimetrica(distancias)) }
        \requiere{(es0EnDiagonalPrincipal(distancias)) }
            
	    \asegura{\\
            (\neg hayCaminoCorrecto(distancias, desde, hasta) \land res = \TLista{}) \lor \\
            (hayCaminoCorrecto(distancias, desde, hasta) \land \\
            esCaminoCorrecto(distancias, res, desde, hasta) \land
            (\paraTodo[unalinea]{i}{\TLista{\ent}}{ \\
				esCaminoCorrecto(distancias, i, desde, hasta) 
			\implica \\ 
        	 distanciaTotal(distancias, res) \leq distanciaTotal(distancias, i)})
            )
        }

        \aux{distanciaTotal}{distancias:  \TLista{\TLista{\ent}}, s: \TLista{\ent}}{\ent}
        {\sum\limits_{k=1}^{|distancias| - 1}{distancias[s[k]][s[k - 1]]}}

        \pred{hayCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, desde: \ent, hasta: \ent}
        {\existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto(distancias, i, desde, hasta)}}

        \pred{esMatrizCuadrada}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego |matriz[i]| = |matriz|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {esMatrizCuadrada(matriz) \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implica \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}
        
        \pred{esCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, posibleCamino: \TLista{\ent}, desde: \ent, hasta: \ent}
        {(|posibleCamino | \geq 2) \land sonCiudadesValidas(|distancias|, posibleCamino)  \yLuego \\ (posibleCamino[i] = desde \land posibleCamino[|posibleCamino| - 1] = hasta) \land \\ 
        \paraTodo[unalinea]{x}{\ent}{1 \leq x < |posibleCamino| \implicaLuego ((distancias[posibleCamino[x]][posibleCamino[x - 1]] \neq 0))} } 
        
        \pred{es0EnDiagonalPrincipal}{matriz: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(matriz)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego matriz[i][i] = 0}
        } 

        \pred{sonCiudadesValidas}{maxCiudades:  \ent, posCamino: \TLista{\ent}}{
            \paraTodo[unalinea]{i}{\ent}{0 \leq i<|posCamino| \implicaLuego 0 \leq posCamino[i] < maxCiudades}
        }

    \end{proc}
    
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item Las mismas ideas que en el 1.3 sobre que la matriz distancia debe ser cuadrada, simetrica y su diagonal principal debe ser 0
				\item La secuencia que devuelve es de al menos 2 elementos, ya que debe contener el desde y el hasta la secuencia para que vayan de un camino a otro
				\item Tambien, no se considera válido que se vaya de A hasta A, sin un camino intermedio que tenga distancia diferente de 1
				\item Las distancias no estan relacionados con la cantidad de nodos que tenga, puede
				tener muchos elementos y otros menos, pero tener aun asi menor distancias
                \item La funcion auxiliar no se indefine nunca, pues empieza en 1, y luego resta - 1, por lo que 
                el menor numero que tiene es 1 - 1, siendo 0, que es un numero valido. Ademas, si el modulo de distancias fuera 1, iria de 1 hasta 1, siendo 0 y evitando que se indefina tambien. Con el 0 ocurre tambien. Y a partir del 2, va sumando las distancias
			\end{enumerate}
		}
	}


\end{enumerate}


%Respuestas del punto 2
\subsection{Correctitud del programa}

\begin {enumerate}
    %TODO
    \item

Para probar que el programa satisface la especificación, debo probar la tripla de Hoare 

    \{P\} S \{Q\}

    donde  
    \begin{itemize}
        \item $P = \{ \\
            \existe[unalinea]{i}{\ent}{0 \leq i < |ciudades| \yLuego ciudades[i].habitantes > 50.000} \land \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego ciudades[i].habitantes \geq 0} \land \\
            \paraTodo[unalinea]{i, j}{\ent}{0 \leq i < j < |ciudades| \implicaLuego ciudades[i].nombre \neq ciudades[j].habitantes} 
        \}$
        \item $Q = res =  \sum\limits_{k=0}^{|secuencia| - 1}{ciudades[k].habitantes}$
    \end{itemize}
    
    Para ello, operamos de la siguiente manera

    $$P \to wp(S1;S2;S3;S4, Q)$$

    O, usando los axiomas 

    $$P \rightarrow wp(S1; wp(S2; wp(S3; wp(S4, Q))))$$

    donde  
    \begin{itemize}
        \item $S1 = i := 0$
        \item $S2 = res := 0$
        \item $S3 = ciclo$ $while$
        \item $S4 = skip$
    \end{itemize}
    
    Vayamos de atrás para adelante y por partes

    1. $wp (skip, Q)$ 
    
    Por axioma 2, $wp(skip, Q) \equiv Q \equiv res =  \sum\limits_{k=0}^{|secuencia| - 1}{ciudades[k].habitantes}$

    Para seguir avanzando, necesitamos relacionar la wp (calculada antes) con el $Q_{c}$ del ciclo. Debemos encontrar un $Q_{c}$ que cumpla
    $Q_{c} \to Q$. Proponemos tomar $Q_{c}=Q$, que respeta la implicación planteada

    2. $wp(S3, Q_{c})$

    LLegada esta parte, necesitamos ver que el ciclo while sea correcto. Esto implica mostrar que valen tanto el Teorema del Invariante como el 
    Teorema de Terminación

    \underline{Teorema del invariante}

    Partimos de 

    \begin{itemize}
        \item $B = \{i < |ciudades| \}$
        \item $res =  \sum\limits_{k=0}^{|ciudades| - 1}{ciudades[k].habitantes}$
    \end{itemize}

    Proponemos como invariante el siguiente predicado: 

    $$I \equiv \{0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes}\}$$

    \begin{itemize}
        \item $(I \land \neg B) \to Q_{c}$
    \end{itemize}

    \begin{align*}
        (I \land \neg B) &\equiv \{0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \land i \geq |ciudades|\} \\
        &\equiv i = |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \\
        &\equiv i = |ciudades| \yLuego res = \sum\limits_{k=0}^{|ciudades| - 1}{ciudades[k].habitantes}
    \end{align*}

    Quedando una expresión exactamente equivalente a $Q_{c}$. Como vale $Q_{c} \to Q_{c}$ (pues $A \to A$ es siempre verdadero), afirmamos que $(I \land \neg B) \to Q_{c}$ vale 


    \begin{itemize}
    \item $ \{I \land B\}$ S $\{I\}$
    \end{itemize}

    Buscamos probar $(I \land B) \to wp(S, I)$

    $$ (I \land B) = (0 \leq i < |ciudades| \land res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes})$$

    $$wp(S, I) \equiv wp(res := res + ciudades[i].habitantes, wp(i := i + 1, I))$$

    Calculamos la wp que necesitamos

    \begin{align*}
        wp (i := i + 1, I) &\equiv def(i + 1) \yLuego I_{i +1}^{i} \\
        &\equiv \True \yLuego (0 \leq i + 1 \leq |ciudades| \land res = \sum\limits_{k=0}^{i}{ciudades[k].habitantes}) \\
        &\equiv -1 \leq i < |ciudades| \land res =  \sum\limits_{k=0}^{i}{ciudades[k].habitantes} 
    \end{align*}

    Volviendo a $wp(S, I) \equiv wp(res := res + ciudades[i].habitantes, wp(i := i + 1, I))$

    Llamaremos $\alpha = -1 \leq i < |ciudades| \land res =  \sum\limits_{k=0}^{i}{ciudades[k].habitantes} $

    $$ wp(res := res + ciudades[i].habitantes, -1 \leq i < |ciuaddes| \land res =  \sum\limits_{k=0}^{i}{ciudades[k].habitantes}) $$
    \begin{align*}
        &\equiv def(res + ciudades[i].habitantes) \yLuego \alpha_{res + ciudades[i].habitantes}^{res} \\
        &\equiv 0 \leq i < |ciudades| \yLuego (-1 \leq i < |ciudades| \land res + ciudades[i].habitantes = \sum\limits_{k=0}^{i}{ciudades[k].habitantes} ) \\
        &\equiv 0 \leq i < |ciudades| \yLuego res = (\sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes}) + ciudades[i].habitantes - ciudades[i].habitantes \\
        &\equiv 0 \leq i < |ciudades| \yLuego res = (\sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes})  \\
    \end{align*}

    Y esto es exactamente equivalente a $(I \land B)$. Como vale $(I \land B) \to (I \land B)$, podemos afirmar que $(I \land B) \to wp(S, I)$ y la tripla de Hoare es correcta


    \begin{itemize}
        \item $ P_{c} \to I$
        \end{itemize}

    Observando el codigo anterior al ciclo, proponemos como $P_{c}$ al predicado $P_{c} \equiv \{i = 0 \land res = 0\}$

    \begin{align*}
        &i = 0 \land res = 0 \to 0 \leq i \leq |ciudades| \land res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \\
        &i = 0 \land res = 0 \to 0 \leq 0 \leq |ciudades| \land res = \sum\limits_{k=0}^{0 - 1}{ciudades[k].habitantes} \\
        &i = 0 \land res = 0 \to 0 \leq 0 \leq |ciudades| \land res = \sum\limits_{k=0}^{-1}{ciudades[k].habitantes} \\
        &i = 0 \land res = 0 \to  0 \leq |ciudades| \land res = \sum\limits_{k=0}^{-1}{ciudades[k].habitantes} \\
        &i = 0 \land res = 0 \to  0 \leq |ciudades| \land res = 0 \\
    \end{align*}

    De aca sacamos que $res = 0 \to res = 0$ \\
    \textcolor{red}{Aclaración: $|ciudades| \geq 0$ es siempre verdadero al ser una cantidad, y las cantidades no pueden ser negativas}

    Entonces, como tenemos $A \to \True$, podemos concluir con que es verdadero

    Probadas todas las sentencias, podemos afirmar que vale el Teorema del Invariante y que el programa es parcialmente correcto.\\
    Vamos ahora con el Teorema de Terminación

    \underline{Teorema de Terminación}




    Ahora para probar que el ciclo termina, tenemos que probar:

    \begin{itemize}
        \item $\{ I \land B \ f_{v} = v_{0}  \}$ S $\{f_{v} < v_{0}\}$  
        \item $ I \land f_{v} \leq 0 \to \neg B$
    \end{itemize}

    Proponemos como función variante $f_{v} = |ciudades| - i$

    \begin{itemize}
        \item 
            $(I \land f_{v} \leq 0) \to \neg B$
    \end{itemize}

    \begin{align*}
        (I \land f_{v} \leq 0) &\equiv (0 \leq i \leq |ciudades| \land res = \sum\limits_{k=0}^{i -1}{ciudades[k].habitantes} \land |ciudades| - i \leq 0) \\
        &\equiv i = |ciudades| \land res = \sum\limits_{k=0}^{i -1}{ciudades[k].habitantes} \\
        &\equiv i = |ciudades| \land res = \sum\limits_{k=0}^{|ciudades| -1}{ciudades[k].habitantes}
    \end{align*}


    \begin{align*}
        \neg B &\equiv i \geq |ciudades|
    \end{align*}


    \begin{align*}
        ((I \land f_{v} \leq 0) \to \neg B) &\equiv (i = |ciudades| \land res = \sum\limits_{k=0}^{|ciudades| -1}{ciudades[k].habitantes} \to i \geq |ciudades|)
    \end{align*}

    Como $i = |ciudades| \to i \leq |ciudades|$, entonces esto es \True . Y por lo tanto $(I \land f_{v} \leq 0) \to \neg B $ vale

    \begin{itemize}
        \item 
            $\{ I \land B \land f_{v} = v_{0}  \}$ S $\{f_{v} < v_{0}\}$
    \end{itemize}
    
    Buscamos ver que  $(I \land B \land f_{v} = v_{0}) \to wp(s, f_{v} < v_{0}) $

    \begin{align*}
        I \land B \land f_{v} = v_{0} &\equiv 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \land i < |ciudades| \land |ciudades| - i = v_{0} \\
            &\equiv 0 \leq i < |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \land |ciudades| - i = v_{0}
    \end{align*}

    $$wp(s, f_{v}<v_{0}) \equiv  wp(res := res + ciudades[i].habitantes, wp(i := i +1, |ciudades| - i < v_{0}))$$

    Vamos a calcular primero la $wp(i := i +1, |ciudades| - i < v_{0}) $
    
    \begin{align*}
        wp(i := i +1, |ciudades| - i < v_{0}) &\equiv def (i + 1) \yLuego (|ciudades| - i < v_{0})_{i + 1}^{i} \\
        &\equiv \True \yLuego (|ciudades| - (i + 1) < v_{0}) \\
        &\equiv |ciudades| - (i + 1) < v_{0}
    \end{align*}

    Ahora, como ya calculamos esa $wp(i := i +1, |ciudades| - i < v_{0}) $, la reemplazamos en  \\
    $$ wp(res := res + ciudades[i].habitantes, wp(i := i +1, |ciudades| - i < v_{0}))$$

    \begin{align*}
        &\equiv def (res + ciudades[i].habitantes) \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res} \\
        &\equiv def(res) \land def(ciudades) \land def(i) \yLuego 0 \leq i < |ciudades| \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res}\\
        &\equiv \True \land \True \land \True \land \yLuego 0 \leq i < |ciudades| \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res}\\
        &\equiv 0 \leq i < |ciudades| \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res}\\
        &\equiv 0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < v_{0}
    \end{align*}

    Finalmente queremos ver que $(I \land B \land f_{v} = v_{0} \to wp(S, f_{v} < v_{0}))$


    \begin{align*}
        0 \leq i < |ciudades| \land |ciudades| - i = v_{0} \to 0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < v_{0}
    \end{align*}

    \textcolor{red}{Aclaración (Como no nos hacia falta el res, lo decidimos sacar y no ponerlo directamente)}

    Por un lado, tenemos $0 \leq i < |ciudades| \to 0 \leq i < |ciudades|$, que es \True

    Y, por el otro 

    \begin{align*}
        &\equiv |ciudades| - i = v_{0} \to |ciudades| - (i + 1) < v_{0} \\
        &\equiv |ciudades| - i = v_{0} \to |ciudades| - i - 1 < |ciudades| - i \\
        &\equiv |ciudades| - i = v_{0} \to - 1 < 0 \\
        &\equiv |ciudades| - i = v_{0} \to True \\
        &\equiv \True   
    \end{align*}

    Probadas estas 2 sentencias del Teorema de  Terminación podemos afirmar que el ciclo termina

    Finalmente, probamos el Teorema del Invariante y el Teorema de Terminación. Por lo tanto, el ciclo es correcto con respecto a su especificación

    3. $wp(S1;S2, P_{c})$

    Del ciclo, recuperamos el $P_{c} \equiv \{i = 0 \land res = 0 \} $

    \begin{align*}
        wp(S1;S2, P_{c}) &\equiv wp(res := 0, wp(i := 0, i = 0 \land res = 0 )) \\
        &\equiv wp(res := 0, def(i + 1) \yLuego (i = 0 \land res = 0)_{0}^{i}) \\
        &\equiv wp(res := 0, \True \yLuego (i = 0 \land res = 0)_{0}^{i}) \\
        &\equiv wp(res := 0, (i = 0 \land res = 0)_{0}^{i}) \\
        &\equiv wp(res := 0, 0 = 0 \land res = 0) \\
        &\equiv wp(res := 0, \True \land res = 0) \\
        &\equiv wp(res := 0, res = 0) \\
        &\equiv def (0) \yLuego (res = 0)_{0}^{res} \\
        &\equiv \True \yLuego (res = 0)_{0}^{res} \\
        &\equiv (res = 0)_{0}^{res} \\
        &\equiv 0 = 0 \\
        &\equiv \True \\
    \end{align*}

    Entonces, $P \to P_{c}$ sería: \\

        $P = \{ \\
        \existe[unalinea]{i}{\ent}{0 \leq i < |ciudades| \yLuego ciudades[i].habitantes > 50.000} \land \\
        \paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego ciudades[i].habitantes \geq 0} \land \\
        \paraTodo[unalinea]{i, j}{\ent}{0 \leq i < j < |ciudades| \implicaLuego ciudades[i].nombre \neq ciudades[j].nombre} 
\} \to \True \\
        \equiv \True$
    
    \textcolor{red}{Aclaración: Cualquier cosa $\to \True$ es $\True$ necesariamente}

    \underline{Conclusión}

    Como ya demostramos los siguientes puntos
    \begin{itemize}
        \item $P \to P_{c}$
        \item Teorema del Invariante para el ciclo
        \item Teorema de Terminación del ciclo
        \item $Q_{c} \to Q$
    \end{itemize}
    
    Entonces, podemos concluir con que el programa es correcto respecto a su especificación
    

    %<><><><><><><><><><><><><><><><>
    % Ej 2.2
    \item

   Debemos agregarle esa nueva condición a la post-condición del programa

   $$ Q \equiv \{ res = \sum\limits^{|ciudades| - 1}_{j = 0}{ciudades[j].habitantes} \land res > 50.000\} $$


   A la hora de volver a realizar la demostración del programa, deberíamos volver a tomar $Q_{c} = Q$ (donde $Q$ tiene la nueva fórmula).
    

   Cuando llegamos al ciclo while y nos enfocamos en realizar la demostración de correctitud; al tener un nuevo 
   $Q_{c}$, debemos ajustar tanto el invariante I como la pre-condición (del ciclo) $P_{c}$ propuestas

   Añadimos las siguientes fórmulas extraídas de los requiere de la especificación.

   \textcircled{1} $ \existe[unalinea]{i}{\ent}{0 \leq |ciudades| < 0 \yLuego ciudades[i].habitantes > 50.000}$  \\
   \textcircled{2} $\paraTodo[unalinea]{i}{\ent}{0 \leq |ciudades| < 0 \implicaLuego ciudades[i].habitantes > 0}$

   Las nuevas propuestas son: 
    \begin{itemize}
        \item $  I \equiv \{  0 \leq i \leq |ciudades| \land res = \sum\limits^{i- 1}_{j = 0}{ciudades[j].habitantes} \land \\ 
        \existe[unalinea]{i}{\ent}{0 \leq |ciudades| < 0 \yLuego ciudades[i].habitantes > 50.000} \land \\
        \paraTodo[unalinea]{i}{\ent}{0 \leq |ciudades| < 0 \implicaLuego ciudades[i].habitantes > 0} \}$
        \item $ P_{c} \equiv \{i = 0 \land res = 0 \land \\
        \existe[unalinea]{i}{\ent}{0 \leq |ciudades| \yLuego ciudades[i].habitantes > 50.000} \land \\
    \paraTodo[unalinea]{i}{\ent}{0 \leq |ciudades| < 0 \implicaLuego ciudades[i].habitantes > 0} \}$
        \item $Q_{c} \equiv Q \equiv res = \sum\limits^{|ciudades| - 1}_{j = 0}{ciudades[j].habitantes} \land res > 50.000$
    \end{itemize}
    



    
    
    Vayamos, sección por sección, viendo qué puede llegar a cambiar de estas nuevas propuestas respecto a la demostración original del ciclo y el programa

    (Antes de continuar, pongamos nombre a ambos predicados para facilitar lectura y notación: 
    \begin{itemize}
    \item$\alpha =  \existe[unalinea]{i}{\ent}{0 \leq |ciudades| < 0\yLuego ciudades[i].habitantes > 50.000}$ \\
    \item$ \beta = \paraTodo[unalinea]{i}{\ent}{0 \leq |ciudades| < 0\implicaLuego ciudades[i].habitantes > 0}$
    \end{itemize}
    )

    Probemos que $Q_{c} \to Q$

    \begin{align*}
      (res = \sum\limits^{|ciudades| - 1}_{j = 0}{ciudades[j].habitantes} \land res > 50.000) \to ( res = \sum\limits^{|ciudades| - 1}_{j = 0}{ciudades[j].habitantes} \land res > 50.000)
    \end{align*}

    Al ser esencialmente los mismos predicados, entonces es verdadero que $Q_{c} \to Q$


    \underline{Teorema del Invariante}

    \begin{itemize}
        \item $P_{c} \to I$
    \end{itemize}

    Para los nuevos $P_{c}$ e $I$, la demostración sigue valiendo igual, ya que tanto $\alpha$ como $\beta$ están explicitamente incorporados a 
    $P_{c}$ e I (y, por ende, se implican). Lo demás, no cambia y continúa siendo la misma implicación que la hecha antes

    \begin{align*}
        &i = 0 \land res = 0 \land \alpha \land \beta \to 0 \leq i \leq |ciudades| \land res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \land \alpha \land \beta\\
        &i = 0 \land res = 0 \land \alpha \land \beta \to 0 \leq 0 \leq |ciudades| \land res = \sum\limits_{k=0}^{0 - 1}{ciudades[k].habitantes}  \land \alpha \land \beta\\
        &i = 0 \land res = 0 \land \alpha \land \beta \to 0 \leq 0 \leq |ciudades| \land res = \sum\limits_{k=0}^{-1}{ciudades[k].habitantes} \land \alpha \land \beta \\
        &i = 0 \land res = 0 \land \alpha \land \beta \to  0 \leq |ciudades| \land res = \sum\limits_{k=0}^{-1}{ciudades[k].habitantes} \land \alpha \land \beta \\
        &i = 0 \land res = 0 \land \alpha \land \beta \to  0 \leq |ciudades| \land res = 0 \land \alpha \land \beta \\
    \end{align*}

    Entonces, como $\alpha \to \alpha$ es $\True$ siempre, lo mismo con beta y con res. Y el $i = 0\to$ 0 $\leq |ciudades|$ es verdadero, al ser
    verdadero la consecuencia con respecto a las premisas siempre ($i = 0\to  0 \leq |ciudades| \equiv \True$) 

    
    \begin{itemize}
        \item $\{ I \land B \}$ S $ \{ I\}$
    \end{itemize}

    A la hora de desarrollar esta prueba, nos centramos en I y la wp(S, I) que hay que calcular. \\
    En particular, la wp(S,I) sigue los mismos pasos (que la hecha en la sección anterior) arrastrando $\alpha $ y $\beta$ hasta el resultado Finalmente
    de la wp. Como $\alpha $ ni $\beta$ no involucran a las variables i ni res (variables afectadas por la implementación en código S), a la
    hora de construir los predicados $I_{i + 1}^{i}$ y $wp(i := i + 1, I)_{res + ciudades[i].habitantes}^{res}$ (parte del procedimiento de 
    reducción de las wp correspondientes) $\alpha $ y $\beta$ son arrastados sin modificarse. \\

    Buscamos probar $(I \land B) \to wp(S, I)$

    $$ (I \land B) = (\alpha \land \beta \land 0 \leq i < |ciudades| \land res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes})$$

    $$wp(S, I) \equiv wp(res := res + ciudades[i].habitantes, wp(i := i + 1, I))$$

    Calculamos la wp que necesitamos

    \begin{align*}
        wp (i := i + 1, I) &\equiv def(i + 1) \yLuego I_{i +1}^{i} \\
        &\equiv \True \yLuego (\alpha \land \beta \land 0 \leq i + 1 \leq |ciudades| \land res = \sum\limits_{k=0}^{i}{ciudades[k].habitantes}) \\
        &\equiv \alpha \land \beta \land -1 \leq i < |ciudades| \land res =  \sum\limits_{k=0}^{i}{ciudades[k].habitantes} 
    \end{align*}

    Volviendo a $wp(S, I) \equiv wp(res := res + ciudades[i].habitantes, wp(i := i + 1, I))$

    Llamaremos $n = -1 \leq i < |ciudades| \land res =  \sum\limits_{k=0}^{i}{ciudades[k].habitantes} $

    $$ wp(res := res + ciudades[i].habitantes, -1 \leq i < |ciuaddes| \land res =  \sum\limits_{k=0}^{i}{ciudades[k].habitantes}) $$
    \begin{align*}
        &\equiv def(res + ciudades[i].habitantes) \yLuego n_{res + ciudades[i].habitantes}^{res} \\
        &\equiv 0 \leq i < |ciudades| \yLuego (\alpha \land \beta \land -1 \leq i < |ciudades| \land res + ciudades[i].habitantes = \sum\limits_{k=0}^{i}{ciudades[k].habitantes} ) \\
        &\equiv \alpha \land \beta \land  0 \leq i < |ciudades| \yLuego res = (\sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes}) + ciudades[i].habitantes - ciudades[i].habitantes \\
        &\equiv \alpha \land \beta \land  0 \leq i < |ciudades| \yLuego res = (\sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes})  \\
    \end{align*}


    Por lo tanto, la tripla de Hoare $\{ I \land B \}$ S $ \{ I\}$ termina siendo igualente correcta

    \begin{itemize}
        \item $(I \land \neg B) \to Q_{c}$
    \end{itemize}

    Siguiendo la operatoria de la sección anterior

    $$ (I \land \neg B) \equiv i = |ciudades| \land res = \sum\limits^{|ciudades|- 1}_{j = 0}{ciudades[j].habitantes} \land \alpha \land \beta $$

    La expresión de res continua siendo la misma que la que aparece en $Q_{c}$. Por lo tanto, no rompe la implicación

    Veamos si a partir de $res = \sum\limits^{|ciudades|- 1}_{j = 0}{ciudades[j].habitantes} \land \alpha \land \beta$ podemos caer en $res > 50.000$

    Por $\alpha$ sabemos que, en la secuencia ciudades, hay (al menos) una tupla cuyo numero de habitantes es $> 50.000$. También, por $\beta$, sabemos
    que en res nunca se suman cantidad negativas.

    Por lo tanto, podemos concluir que siendo que $res = \sum\limits^{|ciudades|- 1}_{j = 0}{ciudades[j].habitantes}$, siempre sera que $res > 50.000$
    
    Al final, podemos afirmar que la implicación continúa siendo validado y que el Teorema del Invariante sigue siendo válido, siendo de esta forma parcialmente correcto. 

    \underline{Teorema de Terminación}
    
    En cuanto al teorema de terminación, termina siendo sustancialmente la misma (que la desarrollada en la sección anterior). La función 
    variante con la guarda B son las mismas. Lo único que aparece nuevo es el invariante I, mas su nueva forma no modifica los resultados obtenidos

    \begin{align*}
        (I \land f_{v} \leq 0) &\equiv (\alpha \land \beta \land 0 \leq i \leq |ciudades| \land res = \sum\limits_{k=0}^{i -1}{ciudades[k].habitantes} \land |ciudades| - i \leq 0) \\
        &\equiv \alpha \land \beta \land i = |ciudades| \land res = \sum\limits_{k=0}^{i -1}{ciudades[k].habitantes} \\
        &\equiv \alpha \land \beta \land i = |ciudades| \land res = \sum\limits_{k=0}^{|ciudades| -1}{ciudades[k].habitantes}
    \end{align*}


    \begin{align*}
        \neg B &\equiv i \geq |ciudades|
    \end{align*}


    \begin{align*}
        ((I \land f_{v} \leq 0) \to \neg B) &\equiv (\alpha \land \beta \land i = |ciudades| \land res = \sum\limits_{k=0}^{|ciudades| -1}{ciudades[k].habitantes} \to i \geq |ciudades|)
    \end{align*}

    Como $\alpha$ y $\beta$ no dan ninguna restricción con respecto a \textbf{i} ni a \textbf{res}, entonces no afecta y lo podemos ignorar \\
    Como $i = |ciudades| \to i \leq |ciudades|$, entonces esto es \True . Y por lo tanto $(I \land f_{v} \leq 0) \to \neg B $ vale

    \begin{itemize}
        \item 
            $\{ I \land B \land f_{v} = v_{0}  \}$ S $\{f_{v} < v_{0}\}$
    \end{itemize}
    
    Buscamos ver que  $(I \land B \land f_{v} = v_{0}) \to wp(s, f_{v} < v_{0}) $
    
    \begin{align*}
        I \land B \land f_{v} = v_{0} &\equiv \alpha \land \beta \land 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \land i < |ciudades| \land |ciudades| - i = v_{0} \\
            &\equiv \alpha \land \beta \land 0 \leq i < |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \land |ciudades| - i = v_{0}
    \end{align*}

     $$wp(s, f_{v}<v_{0}) \equiv  wp(res := res + ciudades[i].habitantes, wp(i := i +1, |ciudades| - i < v_{0}))$$

      Vamos a calcular primero la $wp(i := i +1, |ciudades| - i < v_{0}) $

      \begin{align*}
        wp(i := i +1, |ciudades| - i < v_{0}) &\equiv def (i + 1) \yLuego (|ciudades| - i < v_{0})_{i + 1}^{i} \\
        &\equiv \True \yLuego (|ciudades| - (i + 1) < v_{0}) \\
        &\equiv |ciudades| - (i + 1) < v_{0}
    \end{align*}

    Ahora, como ya calculamos esa $wp(i := i +1, |ciudades| - i < v_{0}) $, la reemplazamos en  \\
    $$ wp(res := res + ciudades[i].habitantes, wp(i := i +1, |ciudades| - i < v_{0}))$$

    \begin{align*}
        &\equiv def (res + ciudades[i].habitantes) \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res} \\
        &\equiv def(res) \land def(ciudades) \land def(i) \yLuego 0 \leq i < |ciudades| \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res}\\
        &\equiv \True \land \True \land \True \land \yLuego 0 \leq i < |ciudades| \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res}\\
        &\equiv 0 \leq i < |ciudades| \yLuego (|ciudades| - (i + 1) < v_{0})_{res + ciudades[i].habitantes}^{res}\\
        &\equiv 0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < v_{0}
    \end{align*}

    Finalmente queremos ver que $(I \land B \land f_{v} = v_{0} \to wp(S, f_{v} < v_{0}))$

    \begin{align*}
        \alpha \land \beta \land 0 \leq i < |ciudades| \land |ciudades| - i = v_{0} \to 0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < v_{0}
    \end{align*}

    \textcolor{red}{Aclaración (Como no nos hacia falta el res, lo decidimos sacar y no ponerlo directamente)}

    Por un lado, tenemos $0 \leq i < |ciudades| \to 0 \leq i < |ciudades|$, que es \True

    Y, por el otro 

    \begin{align*}
        &\equiv |ciudades| - i = v_{0} \to |ciudades| - (i + 1) < v_{0} \\
        &\equiv |ciudades| - i = v_{0} \to |ciudades| - i - 1 < |ciudades| - i \\
        &\equiv |ciudades| - i = v_{0} \to - 1 < 0 \\
        &\equiv |ciudades| - i = v_{0} \to True \\
        &\equiv \True   
    \end{align*}



    Al llegar a la última parte (fuera del ciclo), es simple observar que las WPs calculadas sobre el código pre-ciclo arrastran a $\alpha$ y $\beta$ así como llegan
    (sin modificaciones). Nuevamente, como sus fórmulas no involucran a i ni a res, simplemente se acoplan sin modificación alguna.

    Al final, observamos que tanto $\alpha$ y $\beta$ son expresiones que estan incluidas en P original. Por tanto, P implica la precondición
    del ciclo (construida a partir de todo el desarrollo anterior), la implementación es correcta respecto a su especificación y logramos 
    probar que el valor obtenido es mayor a 50.000.

    \begin{align*}
        wp(S1;S2, P_{c}) &\equiv wp(res := 0, wp(i := 0, i = 0 \land res = 0 )) \\
        &\equiv wp(res := 0, def(i + 1) \yLuego (i = 0 \land res = 0 \land \alpha \land \beta)_{0}^{i}) \\
        &\equiv wp(res := 0, \True \yLuego (i = 0 \land res = 0 \land \alpha \land \beta)_{0}^{i}) \\
        &\equiv wp(res := 0, (i = 0 \land res = 0 \land \alpha \land \beta)_{0}^{i}) \\
        &\equiv wp(res := 0, 0 = 0 \land res = 0 \land \alpha \land \beta) \\
        &\equiv wp(res := 0, \True \land res = 0 \land \alpha \land \beta) \\
        &\equiv wp(res := 0, res = 0 \land \alpha \land \beta) \\
        &\equiv def (0) \yLuego (res = 0  \land \alpha \land \beta)_{0}^{res} \\
        &\equiv \True \yLuego (res = 0 \land \alpha \land \beta)_{0}^{res} \\
        &\equiv (res = 0  \land \alpha \land \beta)_{0}^{res} \\
        &\equiv 0 = 0  \land \alpha \land \beta \\
        &\equiv \True  \land \alpha \land \beta\\
        &\equiv \alpha \land \beta
    \end{align*}

    Y como el 
    
    $P \to P_{c} \equiv \alpha \land \beta \land \paraTodo[unalinea]{i, j}{\ent}{0 \leq i, j < |ciudades| \land i \neq j \implicaLuego ciudades[i].nombre \neq ciudades[j].nombre}  \to \alpha \land \beta$
    
    es una implicación de la forma $A \land B \land C \to A \land B$, que son verdaderas necesariamente

    \underline{Conclusión}

    Como ya demostramos los siguientes puntos
    \begin{itemize}
        \item $P \to P_{c}$
        \item Teorema del Invariante para el ciclo
        \item Teorema de Terminación del ciclo
        \item $Q_{c} \to Q$
    \end{itemize}
    
    Entonces, podemos concluir con que el programa es correcto respecto a su nueva especificación 
    
    $$res=\sum\limits_{j = 0}^{|ciudades| - 1}{ciudades[i].habitantes} \land res > 50.000$$

    y, como demostramos que la nueva especificación es  correcta, entonces el programa siempre que cumpla su precondición va a devolver un
    res $>$ 50.000, además de la sumatoria.



\end{enumerate}
\end{document}
