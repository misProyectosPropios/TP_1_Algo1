\documentclass[10pt,a4paper]{article}

\input{AEDmacros}

\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Especificaci\'on}
\subtitulo{Especificacion y correctitud en SmallLang}

\fecha{\today}

\materia{Algortimo y estructura de datos}
\grupo{Compilados}

\integrante{Frutos, I\~{n}aki}{74/24}{inakifrutos00@gmail.com}
\integrante{Pucciarelli, Francisco}{802/22}{franciscopucciarelli99@gmail.com}
\integrante{Apellido, Nacho}{758/24}{iberney@dc.uba.ar}
\integrante{Di Scala,Juan}{192/23}{jusnmadiscala24012003@gmail.com}

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle

\section{Preguntas}
\subsection{Especificaci\'on}


    \begin{enumerate}
        \item \textbf{grandesCiudades}: A partir de una lista de ciudades, devuelve aquellas que tienen m\'as de 50.000 habitantes.
        \begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}} {\TLista{Ciudad}}\end{proc}

        \item \textbf{sumaDeHabitantes}: Por cuestiones de planificaci\'on urbana, las ciudades registran sus habitantes mayores de edad
        por un lado y menores de edad por el otro. Dadas dos listas de ciudades del mismo largo con los mismos nombres, una
        con sus habitantes mayores y otra con sus habitantes menores, este procedimiento debe devolver una lista de ciudades
        con la cantidad total de sus habitantes.

        \begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{\TLista{Ciudad}}\end{proc}

        \item \textbf{hayCamino}: Un mapa de ciudades est\'a conformada por ciudades y caminos que unen a algunas de ellas. A partir de
        este mapa, podemos definir las distancias entre ciudades como una matriz donde cada celda i, j representa la distancia
        entre la ciudad i y la ciudad j (Fig. 2). Una distancia de 0 equivale a no haber camino entre i y j. Notar que la distancia
        de una ciudad hacia s\'i misma es cero y la distancia entre A y B es la misma que entre B y A.


        Dadas dos ciudades y una matriz de distancias, se pide determinar si existe un camino entre ambas ciudades.

        \begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{\bool}\end{proc}

        \item \textbf{cantidadCaminosNSaltos}: Dentro del contexto de redes inform\'aticas, nos interesa contar la cantidad de “saltos”
        que realizan los paquetes de datos, donde un salto se define como pasar por un nodo.
        As\'i como definimos la matriz de distancias, podemos definir la matriz de conexi\'on entre nodos, donde cada celda i, j
        tiene un 1 si hay un  \'unico camino a un salto de distancia entre el nodo i y el nodo j, y un 0 en caso contrario. En este
        caso, se trata de una matriz de conexi\'on de orden 1, ya que indica cu\'ales pares de nodos poseen 1 camino entre ellos a
        1 salto de distancia.

        Dada la matriz de conexi\'on de orden 1, este procedimineto debe obtener aquella de orden n que indica cu\'antos caminos
        de n saltos hay entre los distintos nodos. Notar que la multiplicaci\'on de una matriz de conexi\'on de orden 1 consigo
        misma nos da la matriz de conexi\'on de orden 2, y as\'i sucesivamente.

        \begin{proc}{cantidadCaminosNSaltos}{\Inout conexion : \TLista{\TLista{\ent}}, \In n : \ent}{}\end{proc}
        %\begin{proc}{cantidadCaminosNSaltos}{\Inout conexi\'on: \TLista{\TLista{\ent}}, \in n: \ent}{\ent}\end{proc}

        \item \textbf{caminoM\'inimo}: Dada una matriz de distancias, una ciudad de origen y una ciudad de destino, este procedimiento
        debe devolver la lista de ciudades que conforman el camino m\'as corto entre ambas. En caso de no existir un camino,
        se debe devolver una lista vac\'ia

        \begin{proc}{caminoM\'inimo}{\In origen : \ent, \In destino : \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}
        \end{proc}
    \end{enumerate}

\subsection{Demostraciones de correctitud}

La funci\'on poblaci\'onTotal recibe una lista de ciudades donde al menos una de ellas es grande (es decir, supera los
50.000 habitantes) y devuelve la cantidad total de habitantes. Dada la siguiente especificaci\'on:

%TODO
%POner procedimiento
\begin{proc} {poblaci\'onTotal}{\In ciudades : \TLista{Ciudad}}{\ent}
{
    \requiere{  \\
        \existe[unalinea]{i}{\ent}{0 \leq i < |ciudades| \yLuego ciudades[i].habitantes > 50.000} \land \\
        \paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego ciudades[i].habitantes \geq 0} \land \\
        \paraTodo[unalinea]{i, j}{\ent}{0 \leq i < j < |ciudades| \implicaLuego ciudades[i].nombre \neq ciudades[j].nombre}
        }
    \asegura{
        res =  \sum\limits_{k=0}^{|secuencia| - 1}{ciudades[i].habitantes}
    }
}
\end{proc}


\begin{lstlisting}
res = 0
i = 0
while (i < ciudades.length) do
    res = res + ciudades[i].habitantes 
    i = i + 1
endwhile
\end{lstlisting}

    \begin{enumerate}
        \item Demostrar que la implementaci\'on es correcta con respecto a la especificaci\'on
        \item Demostrar que el valor devuelto es mayor a 50.000.
    \end{enumerate}


%\newpage


%Respuestas del trabajo
\section{Respuestas}

%Respuestas del punto 1
\subsection{Especificaci\'on}

\begin {enumerate}
    %Ejercicio 1.1)
    %TODO
    \item \begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}} {\TLista{Ciudad}}
		\requiere{sonTodosPositivos(ciudades)} 
		\requiere{sinRepetidos(ciudades)} 
		 
	    \asegura{ \\
			\paraTodo[unalinea]{i}{Ciudad}{((i \in ciudades) \land (i_{1} \geq 50.000)) \Rightarrow (i \in res) \land \\ 
			\paraTodo[unalinea]{j}{Ciudad}{(j \in res) \Rightarrow ((j_{1} \geq 50.000) \land j \in ciudades)}  
			}
        %\left( \left( \forall i:Ciudad \right)\left( \left( \left( i\in ciudades \right)\wedge \left( i_{1}\ge 50.000 \right) \right)\to \left( i\in res \right) \right) \right) \wedge \left( \left( \forall j:Ciudad \right)\left( \left( j\in res \right)\to \left( \left( j_{1}\ge 50.000 \right)\wedge \left( j\in ciudades \right) \right) \right) \right)
        }

	    \pred{sonTodosPositivos}{ciudades: \TLista{Ciudad}}{
			\paraTodo[unalinea]{i}{Ciudad}{i \in ciudades \Rightarrow i_{1} \geq 0}
		}

		\pred{sinRepetidos}{ciudades: \TLista{Ciudad}}{ 
			\paraTodo[unalinea]{i}{Ciudad}{i \in ciudades \Rightarrow \neg(
				\existe[unalinea]{j}{Ciudad}{j \in ciudades \land j_{0} = i_{0}}
			)}
		}
    \end{proc}

	%Comentarios del 1.1)
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item Una ciudad con habitantes negativos (cantidad) no tiene sentido. Si bien no rompe el res (pues no los considera), no lo tomamos como entrada válida
				\item Tampoco tomamos como entrada válida una secuencia que tenga dos (o más) tuplas con $1^{ra}$ componente igual. Si bien en la realidad puede pasar la gran casualidad que existan 2 ciudades distitnas con mismos nombre, vamos a pedir que se distingas utilizando nombres distintos

			\end{enumerate}

		}
	}

    %Ejercicio 1.2)
    %TODO
    \item \begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{\TLista{Ciudad}}
            \requiere{sinRepetidos(menoresDeCiudades) \land sinRepetidos(mayoresDeCiudades) }
            \requiere{|menores| = |mayores| }
            \requiere{(todosElementosPositivos(menoresDeCiudades)) \land (todosElementosPositivos(menoresDeCiudades))}
        
	    \asegura{expresionBooleana2}

        \aux{cantidadApariciones}{secuencia, elementoABuscar}{\ent}{ \\
            \sum\limits_{k=0}^{|secuencia| - 1}{\IfThenElse{secuencia[k] = elementoABuscar}{1}{0}}
            }

	    \pred{sinRepetidos}{seq}{
            \paraTodo[unalinea]{i}{\ent}{expresion}
        } 

        \pred{todosElementosPositivos}{seq}{
            \paraTodo[unalinea]{i}{\ent}{expresion}
        } 
    \end{proc}

	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item 
				\item 
			\end{enumerate}

		}
	}

    %Ejercicio 1.3)
    %TODO
   \item \begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{\bool}

            \requiere{(0 \leq desde < |distancias|) \land (0 \leq hasta < |distancias|) }
            \requiere{(esMatrizCuadrada(distancias))  }
            \requiere{(esMatrizSimetrica(distancias))  }
            \requiere{(todosElementosPositivos(distancias)) }
	    \asegura{\\
            res = \True \iff \existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto(distancias, i, desde, hasta)} 
         %\existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto()}  \Rightarrow res = \true
        }

	    \pred{esCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, posibleCamino: \TLista{\ent}, desde: \ent, hasta: \ent}
        {(|posibleCamino | \geq 2) \implicaLuego (posibleCamino[i] = desde \land posibleCamino[|posibleCamino| - 1] = hasta) \land \\ 
        \paraTodo[unalinea]{x}{\ent}{1 \leq x < |seq| \implicaLuego ((distancias[posibleCamino[x]][posibleCamino[x - 1]] \neq 0))} } 

        \pred{esMatrizCuadrada}{distancias: \TLista{\TLista{\ent}}}
        {\paraTodo{i}{\ent}{0 \leq i < |distancias| \implicaLuego |distancias[i]| = |distancias|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{esMatrizCuadrada(distancias) \yLuego 0 \leq i < |matriz| \implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}
   
        \pred{todosElementosPositivos}{seq}{
            \paraTodo[unalinea]{i}{\ent}{ 0 \leq i < |seq| \implicaLuego
                \paraTodo[unalinea]{j}{\ent}{  0 \leq j < |seq[i]| \implicaLuego seq[i][j] \geq 0}
            }
        }
        
        \pred{es0EnDiagonalPrincipal}{distancias: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(distancias)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego distancias[i][i] = 0}
        }
   \end{proc}

   \fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 

		}
	}

    %Ejercicio 1.4)
    %TODO
    \item \begin{proc}{cantidadCaminosNSaltos}{\Inout conexion : \TLista{\TLista{\ent}}, \In n : \ent}{}
		\requiere{conexion = conexion_{0} }
        \requiere{n > 0 \land }
        \requiere{(esMatrizCuadrada(conexion)) }
        \requiere{(esMatrizSimetrica(conexion)) }
        \requiere{(todosElementos\_1\_o\_0(conexion)) }

	    \asegura{ \\
            (n = 1 \land res = conexion) \lor \\ %Que pasa si en un if then else hay dos condiciones con lo mismo?
            (n > 1 \land \existe[unalinea]{i}{\TLista{\TLista{\TLista{\ent}}}}{|i| = n \yLuego \\ 
                \paraTodo[unalinea]{j}{\ent}{1 \geq j < |i| \implicaLuego esMultiplicacionDe(i[j], i[j - 1])} \land res = i[|i| - 1]
            })
        }
	    
        %Hacer auxiliar que vea si una matriz es multiplicacion de otra
	    
        \pred{esMatrizCuadrada}{distancias: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego |distancias[i]| = |distancias|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}%\paraTodo{i}{\ent}{}}
   
        \pred{todosElementos\_1\_o\_0}{seq}{
            \paraTodo[unalinea]{i}{\ent}{ 0 \leq i < |seq| \implicaLuego
                \paraTodo[unalinea]{j}{\ent}{  0 \leq j < |seq[i]| \implicaLuego (seq[i][j] = 0 \lor seq[i][j] = 1)}
           }
        }

        \pred{es0EnDiagonalPrincipal}{distancias: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(distancias)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego distancias[i][i] = 0}
        } 

    \end{proc}

	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item 
				\item 
			\end{enumerate}

		}
	}

    %Ejercicio 1.5)
    %TODO
    \item \begin{proc}{caminoM\'inimo}{\In origen : \ent, \In destino : \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}

        \requiere{(0 \leq origen < |distancias|) \land (0 \leq destino < |distancias|) }
        \requiere{(esMatrizCuadrada(distancias)) }
        \requiere{(esMatrizSimetrica(distancias)) }
            
	    \asegura{\\
            (\neg hayCaminoCorrecto(distancias, desde, hasta) \land res = \TLista{}) \lor \\
            (hayCaminoCorrecto(distancias, desde, hasta) \land \\
            (\paraTodo[unalinea]{i}{\TLista{\ent}}{ \\
				esCaminoCorrecto(distancias, i, desde, hasta) \land esCaminoCorrecto(distancias, res, desde, hasta)
			\Rightarrow \\ 
        	 distanciaTotal(distancias, res) <= distanciaTotal(distancias, i)})
            )
        }

        \aux{distanciaTotal}{distancias:  \TLista{\TLista{\ent}}, seq: \TLista{\ent}}{\ent}
        {\sum\limits_{k=1}^{|distancias| - 1}{distancias[seq[k]][seq[k - 1]]}}

        \pred{hayCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, desde: \ent, hasta: \ent}
        {\existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto(distancias, i, desde, hasta)}}

        \pred{esMatrizCuadrada}{distancias: \TLista{\TLista{\ent}}}
        {\paraTodo{i}{\ent}{0 \leq i < |distancias| \implicaLuego |distancias[i]| = |distancias|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}
        
        \pred{esCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, posibleCamino: \TLista{\ent}, desde: \ent, hasta: \ent}
        {(|posibleCamino | \geq 2) \implicaLuego (posibleCamino[i] = desde \land posibleCamino[|posibleCamino| - 1] = hasta) \land \\ 
        \paraTodo[unalinea]{x}{\ent}{1 \leq x < |seq| \implicaLuego ((distancias[posibleCamino[x]][posibleCamino[x - 1]] \neq 0))} } 

        \pred{es0EnDiagonalPrincipal}{distancias: \TLista{\TLissta{\ent}}}
        {
            esMatrizCuadrada(distancias)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego distancias[i][i] = 0}
        }
    \end{proc}
    
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item 
				\item 
			\end{enumerate}
		}
	}


\end{enumerate}


%Respuestas del punto 2
\subsection{Correctitud del programa}

\begin {enumerate}
    %TODO
    \item
	
    \fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item 
				\item 
			\end{enumerate}
		}
	}
    
    \item

    \fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item 
				\item 
			\end{enumerate}
		}
	}
\end{enumerate}
\end{document}
