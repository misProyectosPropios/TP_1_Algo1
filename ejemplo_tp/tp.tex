\documentclass[10pt,a4paper]{article}

\input{AEDmacros}

\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Especificaci\'on}
\subtitulo{Especificacion y correctitud en SmallLang}

\fecha{\today}

\materia{Algortimo y estructura de datos}
\grupo{Compilados}

\integrante{Frutos, I\~{n}aki}{74/24}{inakifrutos00@gmail.com}
\integrante{Pucciarelli, Francisco}{802/22}{franciscopucciarelli99@gmail.com}
\integrante{Berney, Ignacio}{758/24}{nachoberney@gmail.com}
\integrante{Di Scala,Juan}{192/23}{jusnmadiscala24012003@gmail.com}

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle

\section{Preguntas}
\subsection{Especificaci\'on}


    \begin{enumerate}
        \item \textbf{grandesCiudades}: A partir de una lista de ciudades, devuelve aquellas que tienen m\'as de 50.000 habitantes.
        \begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}} {\TLista{Ciudad}}\end{proc}

        \item \textbf{sumaDeHabitantes}: Por cuestiones de planificaci\'on urbana, las ciudades registran sus habitantes mayores de edad
        por un lado y menores de edad por el otro. Dadas dos listas de ciudades del mismo largo con los mismos nombres, una
        con sus habitantes mayores y otra con sus habitantes menores, este procedimiento debe devolver una lista de ciudades
        con la cantidad total de sus habitantes.

        \begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{\TLista{Ciudad}}\end{proc}

        \item \textbf{hayCamino}: Un mapa de ciudades est\'a conformada por ciudades y caminos que unen a algunas de ellas. A partir de
        este mapa, podemos definir las distancias entre ciudades como una matriz donde cada celda i, j representa la distancia
        entre la ciudad i y la ciudad j (Fig. 2). Una distancia de 0 equivale a no haber camino entre i y j. Notar que la distancia
        de una ciudad hacia s\'i misma es cero y la distancia entre A y B es la misma que entre B y A.


        Dadas dos ciudades y una matriz de distancias, se pide determinar si existe un camino entre ambas ciudades.

        \begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{\bool}\end{proc}

        \item \textbf{cantidadCaminosNSaltos}: Dentro del contexto de redes inform\'aticas, nos interesa contar la cantidad de “saltos”
        que realizan los paquetes de datos, donde un salto se define como pasar por un nodo.
        As\'i como definimos la matriz de distancias, podemos definir la matriz de conexi\'on entre nodos, donde cada celda i, j
        tiene un 1 si hay un  \'unico camino a un salto de distancia entre el nodo i y el nodo j, y un 0 en caso contrario. En este
        caso, se trata de una matriz de conexi\'on de orden 1, ya que indica cu\'ales pares de nodos poseen 1 camino entre ellos a
        1 salto de distancia.

        Dada la matriz de conexi\'on de orden 1, este procedimineto debe obtener aquella de orden n que indica cu\'antos caminos
        de n saltos hay entre los distintos nodos. Notar que la multiplicaci\'on de una matriz de conexi\'on de orden 1 consigo
        misma nos da la matriz de conexi\'on de orden 2, y as\'i sucesivamente.

        \begin{proc}{cantidadCaminosNSaltos}{\Inout conexion : \TLista{\TLista{\ent}}, \In n : \ent}{}\end{proc}
        %\begin{proc}{cantidadCaminosNSaltos}{\Inout conexi\'on: \TLista{\TLista{\ent}}, \in n: \ent}{\ent}\end{proc}

        \item \textbf{caminoM\'inimo}: Dada una matriz de distancias, una ciudad de origen y una ciudad de destino, este procedimiento
        debe devolver la lista de ciudades que conforman el camino m\'as corto entre ambas. En caso de no existir un camino,
        se debe devolver una lista vac\'ia

        \begin{proc}{caminoM\'inimo}{\In origen : \ent, \In destino : \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}
        \end{proc}
    \end{enumerate}

\subsection{Demostraciones de correctitud}

La funci\'on poblaci\'onTotal recibe una lista de ciudades donde al menos una de ellas es grande (es decir, supera los
50.000 habitantes) y devuelve la cantidad total de habitantes. Dada la siguiente especificaci\'on:

%TODO
%POner procedimiento
\begin{proc} {poblaci\'onTotal}{\In ciudades : \TLista{Ciudad}}{\ent}
{
    \requiere{  \\
        \existe[unalinea]{i}{\ent}{0 \leq i < |ciudades| \yLuego ciudades[i].habitantes > 50.000} \land \\
        \paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego ciudades[i].habitantes \geq 0} \land \\
        %\paraTodo[unalinea]{i, j}{\ent}{0 \leq i < j < |ciudades| \implicaLuego ciudades[i].nombre \neq ciudades[j].nombre}
        }
    \asegura{
        res =  \sum\limits_{k=0}^{|secuencia| - 1}{ciudades[i].habitantes}
    }
}
\end{proc}


\begin{lstlisting}
res = 0
i = 0
while (i < ciudades.length) do
    res = res + ciudades[i].habitantes 
    i = i + 1
endwhile
\end{lstlisting}

    \begin{enumerate}
        \item Demostrar que la implementaci\'on es correcta con respecto a la especificaci\'on
        \item Demostrar que el valor devuelto es mayor a 50.000.
    \end{enumerate}


%\newpage


%Respuestas del trabajo
\section{Respuestas}

%Respuestas del punto 1
\subsection{Especificaci\'on}

\begin {enumerate}
    %Ejercicio 1.1)
    %TODO
    \item \begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}} {\TLista{Ciudad}}
		\requiere{sonTodosPositivos(ciudades)} 
		\requiere{sinRepetidos(ciudades)} 
		 
	    \asegura{ \\
			\paraTodo[unalinea]{i}{Ciudad}{((i \in ciudades) \land (i.habitantes \geq 50.000)) \Rightarrow (i \in res) \land \\ 
			\paraTodo[unalinea]{j}{Ciudad}{(j \in res) \Rightarrow ((j.habitantes \geq 50.000) \land j \in ciudades)} 
			}
        %\left( \left( \forall i:Ciudad \right)\left( \left( \left( i\in ciudades \right)\wedge \left( i_{1}\ge 50.000 \right) \right)\to \left( i\in res \right) \right) \right) \wedge \left( \left( \forall j:Ciudad \right)\left( \left( j\in res \right)\to \left( \left( j_{1}\ge 50.000 \right)\wedge \left( j\in ciudades \right) \right) \right) \right)
        }

	    \pred{sonTodosPositivos}{ciudades: \TLista{Ciudad}}{
			\paraTodo[unalinea]{i}{Ciudad}{i \in ciudades \Rightarrow i.habitantes \geq 0}
		}

		\pred{sinRepetidos}{ciudades: \TLista{Ciudad}}{ 
			\paraTodo[unalinea]{i}{Ciudad}{i \in ciudades \Rightarrow \neg(
				\existe[unalinea]{j}{Ciudad}{j \in ciudades \land j.nombre = i.nombre}
			)}
		}
    \end{proc}

	%Comentarios del 1.1)
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item Una ciudad con habitantes negativos (cantidad) no tiene sentido. Si bien no rompe el res (pues no los considera), no lo tomamos como entrada válida
				\item Tampoco tomamos como entrada válida una secuencia que tenga dos (o más) tuplas con $1^{ra}$ componente igual. Si bien en la realidad puede pasar la gran casualidad que existan 2 ciudades distitnas con mismos nombre, vamos a pedir que se distingas utilizando nombres distintos
				
			\end{enumerate}

		}
	}

    %Ejercicio 1.2)
   	\item \begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{\TLista{Ciudad}}
		\requiere{sinRepetidos(menoresDeCiudades) \land sinRepetidos(mayoresDeCiudades) }
		\requiere{|menoresDeCiudades| = |mayoresDeCiudades| }
		\requiere{(todosElementosPositivos(menoresDeCiudades)) \land (todosElementosPositivos(mayoresDeCiudades))}
		\requiere{estanContenidos(menoresDeCiudades,mayoresDeCiudades) \\ \wedge estanContenidos(mayoresDeCiudades,menoresDeCiudades)}
		
		\asegura{|res|=|mayoresDeCiudades|}
		\asegura{estanContenidos(menoresDeCiudades,res)\land estanContenidos(res,menoresDeCiudades)}
        \asegura{\existe[unalinea]{j}{\ent}{0\leq j<|menoresDeCiudades| \yLuego menoresDeCiudades[j].nombre = t.nombre \land \existe[unalinea]{k}{\ent}{0 \leq k <|mayoresDeCiudades| \yLuego mayoresDeCiudades[k].nombre=t.nombre \land (t.habitantes = menoresDeCiudades[j].habitantes + mayoresDeCiudades[k].habitantes)}}}
		%\asegura{res=\True \iff  ((\exists j:\mathds{Z})((0\leq j<|menoresDeCiudades| \land _{L} menoresDeCiudades[j].nombre=t.nombre) \land (\exists k:\mathds{Z})((0\leq k <|mayoresDeCiudades| \land _{L} mayoresDeCiudades[k].nombre=t.nombre) \land \\ (t.habitantes=menoresDeCiudades[j].habitantes+mayoresDeCiudades[k].habitantes)))}
		

        \pred{sinRepetidos}{s: \TLista{Ciudad}}{
            \paraTodo[unalinea]{i,j}{\ent}{0 \leq i < j < |s| \land i \neq j \implicaLuego s[i].nombre \neq s[j].nombre}
        }
		
		\pred{todosElementosPositivos}{s: \TLista{Ciudad}}{
			\paraTodo[unalinea]{i}{\ent}{0\leq i<|s| \implicaLuego [i].habitantes \geq 0}
		}

		\pred{estanContenidos}{s,t: \TLista{Ciudad}} 
        {\paraTodo[unalinea]{i}{Ciudad}{i \in s \to \existe[unalinea]{j}{Ciudad}{j \in t \land i.nombre = j.nombre}}}
		%{(\forall v: Ciudad)(v\in s\rightarrow (\exists w:Ciudad) (w \in t \land w.nombre=v.nombre)) }
	\end{proc}
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item No hay repetidos entre mayores y menores, para evitar conflictos en los casos en los que no se podrían diferenciar las ciudades si se llaman igual
				\item Por ejercicio, tiene que tener la misma cantidad de elementos la secuencia de menores y mayores
    				\item Tiene que ser >= 0 la cantidad de habitantes, porque si es negativo no tendría sentido alguna, al ser las cantidadaes siempre positivas
				\item Cada ciudad que aparece en alguna secuencia, tiene que aparecer en la otra necesariamente
   			\end{enumerate}

		}
	}

    %Ejercicio 1.3)
    %TODO
   \item \begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{\bool}

            \requiere{(0 \leq desde < |distancias|) \land (0 \leq hasta < |distancias|) }
            \requiere{(esMatrizCuadrada(distancias))  }
            \requiere{(esMatrizSimetrica(distancias))  }
            \requiere{(todosElementosPositivos(distancias)) }
            \requiere{(es0EnDiagonalPrincipal(conexion)) }
	    \asegura{\\
            res = \True \iff \existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto(distancias, i, desde, hasta)} 
         %\existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto()}  \Rightarrow res = \true
        }

	    \pred{esCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, posibleCamino: \TLista{\ent}, desde: \ent, hasta: \ent}
        {(|posibleCamino | \geq 2) \implicaLuego (posibleCamino[i] = desde \land posibleCamino[|posibleCamino| - 1] = hasta) \land \\ 
        \paraTodo[unalinea]{x}{\ent}{1 \leq x < |seq| \implicaLuego ((distancias[posibleCamino[x]][posibleCamino[x - 1]] \neq 0))} } 

        \pred{esMatrizCuadrada}{distancias: \TLista{\TLista{\ent}}}
        {\paraTodo{i}{\ent}{0 \leq i < |distancias| \implicaLuego |distancias[i]| = |distancias|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{esMatrizCuadrada(distancias) \yLuego 0 \leq i < |matriz| \implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}
   
        \pred{todosElementosPositivos}{seq}{
            \paraTodo[unalinea]{i}{\ent}{ 0 \leq i < |seq| \implicaLuego
                \paraTodo[unalinea]{j}{\ent}{  0 \leq j < |seq[i]| \implicaLuego seq[i][j] \geq 0}
            }
        }
        
        \pred{es0EnDiagonalPrincipal}{distancias: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(distancias)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego distancias[i][i] = 0}
        }
   \end{proc}

   \fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item La matriz distancias tienen que ser matrices cuadradas, pues
				asi se definia la matriz distancia en el ejercicio
				\item La matriz distancias también tiene que ser simetrica, pues así
				se definía en el ejercicio
                \item Los elemenentos tienen que ser positivos, ya que las distancias no pueden ser nunca negativas
                \item La distancia de un punto A al mismo es 0, por el ejercicio, y gracias a eso, tenemos que la diagonal principal es
                0 
			\end{enumerate}

		}
	}

    %Ejercicio 1.4)
    %TODO
    \item \begin{proc}{cantidadCaminosNSaltos}{\Inout conexion : \TLista{\TLista{\ent}}, \In n : \ent}{}
		\requiere{conexion = conexion_{0} }
        \requiere{n > 0 }
        \requiere{(esMatrizCuadrada(conexion)) }
        \requiere{(esMatrizSimetrica(conexion)) }
        \requiere{(esMatrizCuadrada(conexion)) }
        \requiere{(es0EnDiagonalPrincipal(conexion)) }

	    \asegura{ \\
            (n = 1 \land conexion = conexion_{0}) \lor \\ %Que pasa si en un if then else hay dos condiciones con lo mismo?
            (n > 1 \land \existe[unalinea]{i}{\TLista{\TLista{\TLista{\ent}}}}{|i| = n \yLuego \\ 
                \paraTodo[unalinea]{j}{\ent}{1 \geq j < |i| \implicaLuego esMultiplicacionDe(i[j], i[j - 1])} \land conexion = i[|i| - 1]
            })
        }
	    
        %Hacer auxiliar que vea si una matriz es multiplicacion de otra
	    
        \pred{esMatrizCuadrada}{distancias: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego |distancias[i]| = |distancias|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}%\paraTodo{i}{\ent}{}}
   
        \pred{todosElementos\_1\_o\_0}{seq}{
            \paraTodo[unalinea]{i}{\ent}{ 0 \leq i < |seq| \implicaLuego
                \paraTodo[unalinea]{j}{\ent}{  0 \leq j < |seq[i]| \implicaLuego (seq[i][j] = 0 \lor seq[i][j] = 1)}
           }
        }

        \pred{es0EnDiagonalPrincipal}{distancias: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(distancias)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego distancias[i][i] = 0}
        } 

    \end{proc}

	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item Un camino de 0 saltos no tiene sentido, pues los caminos tenian al menos 1 salto
				\item Luego, si es de 1 salto, entonces deberia devolver la misma matriz
				\item Si n es mayor o igual a 2, entonces elevarlo ya lo sabemos como se hace correctamente y no tenemos problemas
			\end{enumerate}

		}
	}

    %Ejercicio 1.5)
    %TODO
    \item \begin{proc}{caminoM\'inimo}{\In origen : \ent, \In destino : \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}

        \requiere{(0 \leq origen < |distancias|) \land (0 \leq destino < |distancias|) }
        \requiere{(esMatrizCuadrada(distancias)) }
        \requiere{(esMatrizSimetrica(distancias)) }
        \requiere{(es0EnDiagonalPrincipal(conexion)) }
            
	    \asegura{\\
            (\neg hayCaminoCorrecto(distancias, desde, hasta) \land res = \TLista{}) \lor \\
            (hayCaminoCorrecto(distancias, desde, hasta) \land \\
            esCaminoCorrecto(distancias, res, desde, hasta) \land
            (\paraTodo[unalinea]{i}{\TLista{\ent}}{ \\
				esCaminoCorrecto(distancias, i, desde, hasta) 
			\Rightarrow \\ 
        	 distanciaTotal(distancias, res) <= distanciaTotal(distancias, i)})
            )
        }

        \aux{distanciaTotal}{distancias:  \TLista{\TLista{\ent}}, seq: \TLista{\ent}}{\ent}
        {\sum\limits_{k=1}^{|distancias| - 1}{distancias[seq[k]][seq[k - 1]]}}

        \pred{hayCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, desde: \ent, hasta: \ent}
        {\existe[unalinea]{i}{\TLista{\ent}}{esCaminoCorrecto(distancias, i, desde, hasta)}}

        \pred{esMatrizCuadrada}{distancias: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego |distancias[i]| = |distancias|}}

        \pred{esMatrizSimetrica}{matriz: \TLista{\TLista{\ent}}}
        {\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}}
        
        \pred{esCaminoCorrecto}{distancias: \TLista{\TLista{\ent}}, posibleCamino: \TLista{\ent}, desde: \ent, hasta: \ent}
        {(|posibleCamino | \geq 2) \implicaLuego (posibleCamino[i] = desde \land posibleCamino[|posibleCamino| - 1] = hasta) \land \\ 
        \paraTodo[unalinea]{x}{\ent}{1 \leq x < |seq| \implicaLuego ((distancias[posibleCamino[x]][posibleCamino[x - 1]] \neq 0))} } 
        
        \pred{es0EnDiagonalPrincipal}{distancias: \TLista{\TLista{\ent}}}
        {
            esMatrizCuadrada(distancias)  \yLuego \\
            \paraTodo[unalinea]{i}{\ent}{0 \leq i < |distancias| \implicaLuego distancias[i][i] = 0}
        } 

    \end{proc}
    
	\fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item Las mismas ideas que en el 1.3 sobre que la matriz distancia debe ser cuadrada, simetrica y su diagonal principal debe ser 0
				\item La secuencia que devuelve es de al menos 2 elementos, ya que debe contener el desde y el hasta la secuencia para que vayan de un camino a otro
				\item Tambien, no se considera válido que se vaya de A hasta A, sin un camino intermedio que tenga distancia diferente de 1
				\item Las distancias no estan relacionados con la cantidad de nodos que tenga, puede
				tener muchos elementos y otros menos, pero tener aun asi menor distancias
                \item La funcion auxiliar no se indefine nunca, pues empieza en 1, y luego resta - 1, por lo que 
                el menor numero que tiene es 1 - 1, siendo 0, que es un numero valido. Ademas, si el modulo de distancias fuera 1, iria de 1 hasta 1, siendo 0 y evitando que se indefina tambien. Con el 0 ocurre tambien. Y a partir del 2, va sumando las distancias
			\end{enumerate}
		}
	}


\end{enumerate}


%Respuestas del punto 2
\subsection{Correctitud del programa}

\begin {enumerate}
    %TODO
    \item
	
    Para este ciclo, proponemos como invariante a: $0 \leq i \leq |ciudades| \yLuego$

    Para probar que el programa satisface la especificación, debo probar la tripla de hayCaminoCorrecto

    \{P\} S \{Q\}

    Siendo 
    \begin{itemize}
        \item $P = Escribir choclo del requiere$
        \item $Q = res =  \sum\limits_{k=0}^{|secuencia| - 1}{ciudades[i].habitantes}$
    \end{itemize}
    
    Y para probar la tripla de Hoare, debo hacer

    $$P \rightarrow wp(S1,S2,S3,S4, Q)$$

    O, usando los axiomas 

    $$P \rightarrow wp(S1; wp(S2; wp(S3; wp(S4, Q))))$$

    Siendo 
    \begin{itemize}
        \item $S1 = i := 0$
        \item $S2 = res := 0$
        \item $S3 = ciclo$ $while$
        \item $S4 = skip$
    \end{itemize}
    
    Vamos a ir de atras para adelante

    $wp (skip, Q) = Q = res =  \sum\limits_{k=0}^{|secuencia| - 1}{ciudades[i].habitantes}$

    Al finalizar el ciclo, finaliza el programa. Por lo tanto, debe pasar que $Q_{c} \rightarrow Q$
    Proponemos tomar como $Q_{c} = Q$, que respeta $Q_{c} \rightarrow Q $
    
    $wp(S3, Q_{c})$

    Ahora necesitamos buscar un invariante. A partir del teorema del invariante sabemos que 

    \begin{itemize}
        \item $P_{c} \rightarrow I$
        \item $ \{I \land B \}$  $S_{c}$  $\{I\}$
        \item $(I \land \neg B) \rightarrow Q_{c} $
    \end{itemize}
    
    Nos enfocamos en el tercero:

    $ (I \land \neg B) \rightarrow Q_{c} $

    Tenemos como datos a $B$ y a $Q_{c}$ (el que propusimos antes)

    Ahora, a partir de esto y un poco de imaginación, podemos proponer el invariante

    $$ 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[i].habitantes}$$

    Observando el código pre-ciclo y que $P_{c} \rightarrow I $, proponemos como $P_{c}$ a

    $$i=0 \land res = 0$$

    Aca ponemos la verificacion de correctitud del ciclo

    \begin{itemize}
        \item $(i = 0 \land res = 0) \rightarrow 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[i].habitantes}$
        
        Es verdadero, pues, al reemplazar i por 0 en el 2do queda: $0 \leq 0 \leq |ciudades|$. Al ser $|ciudades| \geq 0$
        Y el $0 = \sum\limits_{k=0}^{0 - 1}{ciudades[i].habitantes}$ que es verdadero

        \item $\{I \land B\}$  S $\{I\} \equiv \{I \land B\} \rightarrow wp(s,i)$
        \\
        \\
        Calculo Auxiliar \\ 
        \\
         ${I \land B } \equiv {0 \leq i < |ciudades|\land res=\sum ciudades[j].habitantes}$ \\
         $wp(s,i)\equiv wp(res=res+ciudades[i].habitantes \land wp_{1}(i=i+1,I))$ \\
         $wp_{1}(i=i+1,I) \equiv def(i+1) \land_{L}I_{i+1}  $ \\
         $\equiv 0 \leq i + 1 \leq |ciudades| \land res = \sum\limits_{k=0}^{i + 1 - 1}{ciudades[k].habitantes} $ \\
         $ \equiv 0 \leq i + 1 \leq |ciudades|  \land res = \sum\limits_{k=0}^{i}{ciudades[k].habitantes}$ 

         Vuevlo a \\
         $ wp(s,i)\equiv wp(res=res+ciudades[i].habitantes \land wp_{1}(i=i+1,I))$
         \\
         \\ 
         Y lo reemplazamos \\
         $ wp(s,i)\equiv wp(res=res+ciudades[i].habitantes, 0 \leq i \leq |ciudades|\land res=\sum ciudades[j].habitantes$ \\

         $ \equiv def (res + ciudades[i].habitantes) \yLuego wp(i := i +1, I)_{res + ciudades[i].habitantes}^{res}$

         $ \equiv ((def(res) \land def(ciudades[i].habitantes) \land def(i)) \yLuego 0 \leq i < |ciudades|) \yLuego wp(i := i +1, I)_{res + ciudades[i].habitantes}^{res}$ \\

        $ \equiv (0 \leq i < |ciudades| \yLuego (o \leq i + 1 \leq |ciudades| \land res + ciudades[i].habitantes = \sum\limits_{j=0}^{i}{ciudades[j].habitantes}))$

        $ \equiv 0 \leq i < |ciudades| \land res = \sum\limits_{j=0}^{i - 1}{ciudades[j].habitantes} \\\text{(A la sumatoria le sacamos restamos el ultimo termino)}$ 

        Al final: 

        $ wp(S, I) \equiv \{ o \leq i < |ciudades| \land res = \sum\limits_{j=0}^{i - 1}{ciudades[j].habitantes}\}$

        que es exactamente igual a \{ $I \land B$\}. Por lo tanto podemos afirmar que $\{I \land B\} \rightarrow$ wp(S,I)
    y que vale la tripla de Hoare
        
        \item
            $ (I \land \neg B) \to Q_{c}$    \\
            $ I \land \neg B \equiv 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[k].habitantes} \land i \leq |ciudades| $ \\
            $ I \land \neg B \equiv i = |ciudades| \yLuego res = \sum\limits_{k=0}^{|ciudades| - 1}{ciudades[k].habitantes}$

            Que es exactamente la misma formula que $Q_{c}$, por lo tanto la implicación vale.

            Como valen los 3 requerimientos del Teorema del Invariante, podemos afirmar que el programa es 
            parcialmente correcto respecto a su

    
%     $ 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[i].habitantes}$
        \end{itemize}
    Ahora para probar que el ciclo termina, tenemos que probar:

    \begin{itemize}
        \item $\{ I \land B \ f_{v} = v_{0}  \}$ S $\{f_{v} < v_{0}\}$  
        \item $ I \land f_{v} \leq 0 \to \neg B$
    \end{itemize}

    Vamos a probarlo:

    \begin{itemize}
        \item 
            $\{ I \land B \ f_{v} = v_{0}  \}$ S $\{f_{v} < v_{0}\}$

            Teniendo en cuenta esto: 
            \begin{itemize}
                \item Invariante  $\equiv 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[i].habitantes}$
                \item B $ \equiv i < |ciudades|$
                \item Funcion variante (que proponemos): $|ciudades| - i$
            \end{itemize}

            Veamos: 

            $0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[i].habitantes} \land i < |ciudades| \land |ciudades| - i = v_{0} \to wp(S, f_{v} < v_{0})$
    
    
            Calculemos la $wp(res := res + ciudades[i].habitantes; i := i + 1, |ciudades| - i < v_{0})$
            \begin{align*}
                \equiv &wp(res := res + ciudades[i].habitantes, wp(i := i + 1, |ciudades| - i < v_{0})) \\
                \equiv &wp(res := res + ciudades[i].habitantes, def (i + 1) \yLuego |ciudades| - (i + 1) < v_{0}) \\
                \equiv &wp(res := res + ciudades[i].habitantes, |ciudades| - (i + 1) < v_{0}) \\
                \equiv &def(res + ciudades[i].habitantes) \yLuego |ciudades| - (i + 1) < v_{0} \\
                \equiv &def(res) \land def(ciudades) \land def(i) \yLuego 0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < v_{0} \\
                \equiv &0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < v_{0}
            \end{align*}


            Ya tenemos cual es la wp, ahora probemos que la implicacion es correcta
           $ 0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[i].habitantes} \land i < |ciudades| \land |ciudades| - i = v_{0} \to wp(S, f_{v} < v_{0}) $

        Nos parece que el res no nos hara falta, por lo que lo sacamos

            \begin{align*}
                0& \leq i \leq |ciudades| \land i < |ciudades| \land |ciudades| - i = v_{0} \to wp(S, f_{v} < v_{0}) \\
                0& \leq i < |ciudades| \land |ciudades| - i = v_{0} \to 0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < v_{0} \\
                0& \leq i < |ciudades| \land |ciudades| - i = v_{0} \to 0 \leq i < |ciudades| \yLuego |ciudades| - (i + 1) < |ciudades| - i \\
                0& \leq i < |ciudades| \land |ciudades| - i = v_{0} \to 0 \leq i < |ciudades| \yLuego - 1 < 0 \\
                0& \leq i < |ciudades| \land |ciudades| - i = v_{0} \to 0 \leq i < |ciudades| \yLuego \True\\
                0& \leq i < |ciudades| \land |ciudades| - i = v_{0} \to 0 \leq i < |ciudades|
            \end{align*}
            \text{Y como i esta entre 0 y el modulo de ciudades y -1, entonces es correcto este punto}

            Ahora, nos falta probar el otro requerimiento para poder decir que el ciclo termina
        \item $ I \land f_{v} \leq 0 \to \neg B$
            
            $$  0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{k=0}^{i - 1}{ciudades[i].habitantes} \land |ciudades| - i \leq 0 \to i \geq |ciudades|$$

        \end{itemize}




    \fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item 

    
    




				\item 
			\end{enumerate}
		}
	}
    
    \item

    \fbox{
		\parbox[b]{\linewidth}{
			 \textbf{\underline{\emph{Comentarios:}}} \\
			 \begin{enumerate}
				\item 
				\item 
			\end{enumerate}
		}
	}
\end{enumerate}
\end{document}
